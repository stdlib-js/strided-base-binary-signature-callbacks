{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport resolve from '@stdlib/strided-base-dtype-resolve-str' ;\nimport Complex64 from '@stdlib/complex-float32' ;\nimport Complex128 from '@stdlib/complex-float64' ;\nimport wrap from '@stdlib/complex-base-wrap-function' ;\n\n\n// VARIABLES //\n\nvar C64 = 'complex64';\nvar C128 = 'complex128';\nvar CTORS = {\n\t'complex64': Complex64,\n\t'complex128': Complex128\n};\n\n\n// FUNCTIONS //\n\n/**\n* Resolves a callback based on provided dtypes.\n*\n* @private\n* @param {Object} table - callback table\n* @param {Function} table.default - default callback\n* @param {Function} table.complex64 - callback for single-precision complex floating-point numbers\n* @param {Function} table.complex128 - callback for double-precision complex floating-point numbers\n* @param {string} t1 - dtype for first argument\n* @param {string} t2 - dtype for second argument\n* @param {string} t3 - dtype for return value\n* @returns {Function} callback\n*/\nfunction resolveCallback( table, t1, t2, t3 ) {\n\tif ( t3 === C64 || t3 === C128 ) {\n\t\tif ( t1 === t2 && t2 === t3 ) {\n\t\t\treturn table[ t3 ];\n\t\t}\n\t\treturn wrap( table[ t3 ], 2, CTORS[ t3 ] );\n\t}\n\tif ( t3 === 'generic' ) {\n\t\tif ( t1 === C128 || t2 === C128 ) {\n\t\t\tif ( t1 === t2 ) {\n\t\t\t\treturn table[ t1 ];\n\t\t\t}\n\t\t\treturn wrap( table[ C128 ], 2, CTORS[ C128 ] );\n\t\t}\n\t\tif ( t1 === C64 || t2 === C64 ) {\n\t\t\tif ( t1 === t2 ) {\n\t\t\t\treturn table[ t1 ];\n\t\t\t}\n\t\t\treturn wrap( table[ C64 ], 2, CTORS[ C64 ] );\n\t\t}\n\t\t// Fall-through...\n\t}\n\treturn table.default;\n}\n\n\n// MAIN //\n\n/**\n* Assigns callbacks to binary interfaces according to type promotion rules.\n*\n* ## Notes\n*\n* -   The function assumes that the provided signature array has the following properties:\n*\n*     -   a strided array having a stride length of `3` (i.e., every `3` elements define a binary interface signature).\n*     -   for each signature (i.e., set of three consecutive non-overlapping strided array elements), the first two elements are the input data types and the third element is the return data type.\n*     -   all signatures follow type promotion rules.\n*\n* -   Based on type promotion rules, we can simply use the callback for `float64` (i.e., the assumed \"default\") for all interfaces not involving complex numbers, even for `float32`, as we shouldn't need to explicitly downcast strided array values. The only time we need to return `float32` values is when input arrays are already `float32` or of a type which can be safely represented in `float32` without concern for truncation.\n*\n* @param {Object} table - callback table\n* @param {Function} table.default - default callback\n* @param {Function} table.complex64 - callback for single-precision complex floating-point numbers\n* @param {Function} table.complex128 - callback for double-precision complex floating-point numbers\n* @param {ArrayLikeObject} signatures - strided array containing binary interface signatures\n* @returns {Array<Function>} list of callbacks\n*\n* @example\n* import signatures from '@stdlib/strided-base-binary-dtype-signatures' ;\n* import add from '@stdlib/math-base-ops-add' ;\n* import cadd from '@stdlib/math-base-ops-cadd' ;\n* import caddf from '@stdlib/math-base-ops-caddf' ;\n*\n* var dtypes = [\n*     'float64',\n*     'float32',\n*     'int32',\n*     'uint8'\n* ];\n*\n* var sigs = signatures( dtypes, dtypes, dtypes );\n* // returns [...]\n*\n* var table = {\n*     'default': add,\n*     'complex64': caddf,\n*     'complex128': cadd\n* };\n*\n* var list = callbacks( table, sigs );\n* // returns [...]\n*/\nfunction callbacks( table, signatures ) {\n\tvar out;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < signatures.length; i += 3 ) {\n\t\tt1 = resolve( signatures[ i ] );\n\t\tt2 = resolve( signatures[ i+1 ] );\n\t\tt3 = resolve( signatures[ i+2 ] );\n\t\tout.push( resolveCallback( table, t1, t2, t3 ) );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default callbacks;\n"],"names":["C64","C128","CTORS","complex64","Complex64","complex128","Complex128","resolveCallback","table","t1","t2","t3","wrap","default","callbacks","signatures","out","i","length","resolve","push"],"mappings":";;sWA8BA,IAAIA,EAAM,YACNC,EAAO,aACPC,EAAQ,CACXC,UAAaC,EACbC,WAAcC,GAmBf,SAASC,EAAiBC,EAAOC,EAAIC,EAAIC,GACxC,GAAKA,IAAOX,GAAOW,IAAOV,EACzB,OAAKQ,IAAOC,GAAMA,IAAOC,EACjBH,EAAOG,GAERC,EAAMJ,EAAOG,GAAM,EAAGT,EAAOS,IAErC,GAAY,YAAPA,EAAmB,CACvB,GAAKF,IAAOR,GAAQS,IAAOT,EAC1B,OAAKQ,IAAOC,EACJF,EAAOC,GAERG,EAAMJ,EAAOP,GAAQ,EAAGC,EAAOD,IAEvC,GAAKQ,IAAOT,GAAOU,IAAOV,EACzB,OAAKS,IAAOC,EACJF,EAAOC,GAERG,EAAMJ,EAAOR,GAAO,EAAGE,EAAOF,IAIvC,OAAOQ,EAAMK,QAmDd,SAASC,EAAWN,EAAOO,GAC1B,IAAIC,EACAP,EACAC,EACAC,EACAM,EAGJ,IADAD,EAAM,GACAC,EAAI,EAAGA,EAAIF,EAAWG,OAAQD,GAAK,EACxCR,EAAKU,EAASJ,EAAYE,IAC1BP,EAAKS,EAASJ,EAAYE,EAAE,IAC5BN,EAAKQ,EAASJ,EAAYE,EAAE,IAC5BD,EAAII,KAAMb,EAAiBC,EAAOC,EAAIC,EAAIC,IAE3C,OAAOK"}